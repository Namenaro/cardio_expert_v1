import bisect
from typing import List


def find_closest_sorted(time: List[float], time_moment_sec: float) -> int:
    """
    Находит индекс элемента в отсортированном списке `time`, значение которого
    наиболее близко к `time_moment_sec`.

    Использует бинарный поиск (модуль `bisect`) для эффективного поиска —
    сложность O(log n) вместо O(n) у линейного поиска.

    Args:
        time (List[float]): Отсортированный список временных отметок (по возрастанию).
            Метод предполагает, что список уже отсортирован. Если это не так,
            результат будет некорректным.
        time_moment_sec (float): Искомое значение времени (в секундах),
            к которому нужно найти ближайшую временную отметку.

    :return:  Индекс элемента в списке `time`, который наиболее близок
            к `time_moment_sec`. Если есть два одинаково близких элемента
            (например, при чётном расстоянии), возвращается индекс меньшего из них.

    Raises:
        ValueError: Если входной список `time` пуст.

    Алгоритм работы:
        1. Использует `bisect.bisect_left()` для нахождения позиции вставки
           `time_moment_sec` в отсортированный список — это даёт индекс первого
           элемента, который >= `time_moment_sec`.
        2. Рассматривает два кандидата на «ближайший элемент»:
           - элемент непосредственно перед позицией вставки (pos - 1);
           - элемент на позиции вставки (pos).
        3. Сравнивает абсолютные разницы между `time_moment_sec` и значениями
           этих двух кандидатов.
        4. Возвращает индекс того элемента, у которого разница меньше.

    """
    if not time:
        raise ValueError("Список `time` не может быть пустым")

    # Находим позицию вставки — индекс первого элемента >= time_moment_sec
    pos = bisect.bisect_left(time, time_moment_sec)

    # Обрабатываем крайние случаи
    if pos == 0:
        return 0  # Все элементы больше time_moment_sec → ближайший — первый
    if pos == len(time):
        return len(time) - 1  # Все элементы меньше → ближайший — последний

    # Сравниваем соседей: элемент перед pos и элемент на pos
    before = time[pos - 1]
    after = time[pos]

    # Возвращаем индекс того, у которого абсолютная разница меньше
    if abs(before - time_moment_sec) <= abs(after - time_moment_sec):
        return pos - 1
    else:
        return pos
